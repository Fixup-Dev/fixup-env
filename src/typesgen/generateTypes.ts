import { writeFileSync } from 'fs';
import type { Schema } from '../schema/types.js';

/**
 * Generate TypeScript declaration file from schema
 */
export function generateTypes(schema: Schema, outputPath: string): void {
  const lines: string[] = [];

  lines.push('// Generated by fixup-env');
  lines.push('// Do not edit this file manually');
  lines.push('');
  lines.push('declare namespace NodeJS {');
  lines.push('  interface ProcessEnv {');

  // Sort keys: required first, then optional
  const sortedKeys = Object.entries(schema.keys)
    .sort(([_, a], [__, b]) => {
      if (a.required !== b.required) {
        return a.required ? -1 : 1;
      }
      return a.name.localeCompare(b.name);
    });

  for (const [keyName, keyDef] of sortedKeys) {
    const typeString = generateTypeString(keyDef);
    const comment = generateTypeComment(keyDef);

    if (comment) {
      lines.push(`    // ${comment}`);
    }

    const optional = keyDef.required ? '' : '?';
    lines.push(`    ${keyName}${optional}: ${typeString};`);
  }

  lines.push('  }');
  lines.push('}');
  lines.push('');
  lines.push('export {};');

  const content = lines.join('\n');
  writeFileSync(outputPath, content, 'utf-8');
}

/**
 * Generate TypeScript type string for a schema key
 */
function generateTypeString(keyDef: Schema['keys'][string]): string {
  switch (keyDef.type) {
    case 'string':
      if (keyDef.enum) {
        return keyDef.enum.map(v => `"${v}"`).join(' | ');
      }
      return 'string';

    case 'number':
    case 'int':
      return 'string'; // Environment variables are always strings

    case 'boolean':
      return 'string'; // Environment variables are always strings

    case 'url':
      return 'string';

    case 'email':
      return 'string';

    case 'enum':
      if (keyDef.enum) {
        return keyDef.enum.map(v => `"${v}"`).join(' | ');
      }
      return 'string';

    case 'port':
      return 'string';

    default:
      return 'string';
  }
}

/**
 * Generate comment for a schema key
 */
function generateTypeComment(keyDef: Schema['keys'][string]): string | null {
  const parts: string[] = [];

  if (keyDef.description) {
    parts.push(keyDef.description);
  }

  if (keyDef.default !== undefined) {
    parts.push(`default: ${keyDef.default}`);
  }

  if (keyDef.example !== undefined) {
    parts.push(`example: ${keyDef.example}`);
  }

  if (keyDef.deprecated) {
    parts.push('deprecated');
    if (keyDef.replacedBy) {
      parts.push(`use ${keyDef.replacedBy} instead`);
    }
  }

  return parts.length > 0 ? parts.join(', ') : null;
}
